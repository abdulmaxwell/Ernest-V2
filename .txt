import fs from 'fs';
import path from 'path';
import { fileURLToPath, pathToFileURL } from 'url';
import dotenv from 'dotenv';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const commands = {};
export const commandDescriptions = {};

// Enhanced emoji system with categories and reactions
const commandEmojis = {
    // System & Info
    'help': 'ðŸ¤–', 'ping': 'ðŸ“', 'info': 'ðŸ“Š', 'status': 'ðŸ’¡', 'version': 'ðŸ”¢',
    
    // Moderation & Admin
    'ban': 'ðŸ”¨', 'kick': 'ðŸ‘¢', 'mute': 'ðŸ”‡', 'warn': 'âš ï¸', 'clear': 'ðŸ§¹',
    
    // Fun & Entertainment
    'joke': 'ðŸ˜‚', 'meme': 'ðŸ–¼ï¸', 'quote': 'ðŸ’¬', 'dice': 'ðŸŽ²', 'flip': 'ðŸª™',
    'fact': 'ðŸ§ ', 'trivia': 'ðŸŽ¯', 'story': 'ðŸ“š', 'riddle': 'ðŸ§©',
    
    // Utility & Tools
    'weather': 'ðŸŒ¤ï¸', 'time': 'ðŸ•’', 'calc': 'ðŸ§®', 'remind': 'â°', 'convert': 'ðŸ”„',
    'search': 'ðŸ”', 'translate': 'ðŸŒ', 'qr': 'ðŸ“±', 'shorten': 'ðŸ”—',
    
    // Media & Content
    'download': 'â¬‡ï¸', 'image': 'ðŸ–¼ï¸', 'music': 'ðŸŽµ', 'video': 'ðŸŽ¬', 'gif': 'ðŸŽ­',
    
    // Social & Interaction
    'poll': 'ðŸ“Š', 'vote': 'ðŸ—³ï¸', 'announce': 'ðŸ“¢', 'welcome': 'ðŸ‘‹', 'goodbye': 'ðŸ‘‹',
    
    // Gaming
    'game': 'ðŸŽ®', 'leaderboard': 'ðŸ†', 'points': 'â­', 'level': 'ðŸ“ˆ',
    
    // Special reactions
    '_success': ['âœ…', 'ðŸŽ‰', 'ðŸ’¯', 'ðŸ”¥', 'âš¡'],
    '_error': ['âŒ', 'ðŸ’¥', 'ðŸš«', 'ðŸ˜µ'],
    '_thinking': ['ðŸ¤”', 'ðŸ’­', 'ðŸ§ ', 'âš¡'],
    '_working': ['âš™ï¸', 'ðŸ”§', 'ðŸ’»', 'ðŸ› ï¸'],
    '_default': 'âœ¨'
};

// Cool loading animations
const loadingAnimations = [
    ['â ‹', 'â ™', 'â ¹', 'â ¸', 'â ¼', 'â ´', 'â ¦', 'â §', 'â ‡', 'â '],
    ['ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒ•', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜'],
    ['â­', 'ðŸŒŸ', 'âœ¨', 'ðŸ’«', 'â­'],
    ['ðŸ”´', 'ðŸŸ ', 'ðŸŸ¡', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ£']
];

// User activity tracking
const userActivity = new Map();
const commandStats = new Map();
const cooldowns = new Map();

// Smart response system
class SmartResponder {
    constructor() {
        this.contextMemory = new Map();
        this.userPreferences = new Map();
        this.conversationFlow = new Map();
    }

    // Remember conversation context
    rememberContext(userId, command, response) {
        if (!this.contextMemory.has(userId)) {
            this.contextMemory.set(userId, []);
        }
        const userContext = this.contextMemory.get(userId);
        userContext.push({ command, response, timestamp: Date.now() });
        
        // Keep only last 10 interactions
        if (userContext.length > 10) {
            userContext.shift();
        }
    }

    // Get personalized greeting
    getPersonalizedGreeting(userId) {
        const activity = userActivity.get(userId);
        const hour = new Date().getHours();
        
        let timeGreeting = '';
        if (hour < 12) timeGreeting = 'Good morning';
        else if (hour < 17) timeGreeting = 'Good afternoon';
        else timeGreeting = 'Good evening';

        if (activity && activity.lastSeen) {
            const lastSeen = Date.now() - activity.lastSeen;
            if (lastSeen > 86400000) { // 24 hours
                return `${timeGreeting}! Welcome back! ðŸŽ‰`;
            } else if (lastSeen > 3600000) { // 1 hour
                return `${timeGreeting}! Good to see you again! ðŸ˜Š`;
            }
        }
        
        return `${timeGreeting}! ðŸ‘‹`;
    }
}

const smartResponder = new SmartResponder();

// Advanced presence management with realistic typing speeds
const handleAdvancedPresence = async (sock, msg, presenceSettings, commandName) => {
    if (!presenceSettings.TYPING && !presenceSettings.AUDIO) return;

    const from = msg.key.remoteJid;
    const isComplexCommand = ['help', 'weather', 'search', 'translate'].includes(commandName);
    
    try {
        // Show appropriate presence based on command type
        const presenceType = presenceSettings.AUDIO ? 'recording' : 'composing';
        await sock.sendPresenceUpdate(presenceType, from);
        
        // Realistic typing duration based on command complexity
        const typingDuration = isComplexCommand ? 
            Math.random() * 3000 + 2000 : // 2-5 seconds for complex
            Math.random() * 1500 + 1000;  // 1-2.5 seconds for simple
        
        setTimeout(async () => {
            try {
                await sock.sendPresenceUpdate('paused', from);
            } catch (error) {
                console.error('Error hiding presence:', error);
            }
        }, typingDuration);
        
        return typingDuration;
    } catch (error) {
        console.error('Error setting presence:', error);
        return 1000;
    }
};

// Cool loading message with animation
const sendLoadingMessage = async (sock, from, messageKey) => {
    const animation = loadingAnimations[Math.floor(Math.random() * loadingAnimations.length)];
    let frame = 0;
    
    const loadingMsg = await sock.sendMessage(from, {
        text: `${animation[0]} Processing your request...`
    });
    
    const interval = setInterval(async () => {
        frame = (frame + 1) % animation.length;
        try {
            await sock.sendMessage(from, {
                text: `${animation[frame]} Processing your request...`,
                edit: loadingMsg.key
            });
        } catch (err) {
            clearInterval(interval);
        }
    }, 200);
    
    // Clean up after 3 seconds
    setTimeout(() => {
        clearInterval(interval);
    }, 3000);
    
    return loadingMsg;
};

// Smart reaction system
const getSmartReaction = (commandName, success = true, userId = null) => {
    // Check if user has preferences
    const userPrefs = smartResponder.userPreferences.get(userId);
    
    if (success) {
        if (commandEmojis[commandName]) {
            return commandEmojis[commandName];
        }
        
        // Random success reaction
        const successReactions = commandEmojis._success;
        return successReactions[Math.floor(Math.random() * successReactions.length)];
    } else {
        const errorReactions = commandEmojis._error;
        return errorReactions[Math.floor(Math.random() * errorReactions.length)];
    }
};

// Command analytics and stats
const trackCommandUsage = (commandName, userId) => {
    // Track global command stats
    const currentCount = commandStats.get(commandName) || 0;
    commandStats.set(commandName, currentCount + 1);
    
    // Track user activity
    if (!userActivity.has(userId)) {
        userActivity.set(userId, {
            commandCount: 0,
            favoriteCommands: new Map(),
            firstSeen: Date.now(),
            lastSeen: Date.now()
        });
    }
    
    const activity = userActivity.get(userId);
    activity.commandCount++;
    activity.lastSeen = Date.now();
    
    const cmdCount = activity.favoriteCommands.get(commandName) || 0;
    activity.favoriteCommands.set(commandName, cmdCount + 1);
};

// Cooldown system to prevent spam
const checkCooldown = (userId, commandName) => {
    const cooldownKey = `${userId}-${commandName}`;
    const lastUsed = cooldowns.get(cooldownKey);
    const cooldownTime = 3000; // 3 seconds default
    
    if (lastUsed && Date.now() - lastUsed < cooldownTime) {
        return false;
    }
    
    cooldowns.set(cooldownKey, Date.now());
    return true;
};

// Enhanced command loading with hot-reload support
export const loadCommands = async (reload = false) => {
    const commandsPath = path.join(__dirname, '../commands');
    console.log('Available commands:', Object.keys(commandList));
    if (!fs.existsSync(commandsPath)) {
        console.warn('âš ï¸ Commands directory not found, creating...');
        fs.mkdirSync(commandsPath, { recursive: true });
        return commands;
    }
    
    const commandFiles = fs.readdirSync(commandsPath).filter(
        file => file.endsWith('.js') && !file.startsWith('_')
    );

    let loadedCount = 0;
    let errorCount = 0;

    for (const file of commandFiles) {
        const modulePath = pathToFileURL(path.join(commandsPath, file)).href;
        const commandName = path.basename(file, '.js');

        try {
            // Clear module cache for hot-reload
            if (reload && import.meta.url) {
                delete require.cache[require.resolve(path.join(commandsPath, file))];
            }
            
            const module = await import(`${modulePath}?t=${Date.now()}`);

            if (typeof module.default === 'function') {
                commands[commandName] = module.default;
                loadedCount++;

                // Enhanced command metadata
                if (module.default.description) {
                    commandDescriptions[commandName] = {
                        description: module.default.description,
                        usage: module.default.usage || `${process.env.PREFIX || '!'}${commandName}`,
                        category: module.default.category || 'general',
                        cooldown: module.default.cooldown || 3000,
                        adminOnly: module.default.adminOnly || false,
                        emoji: module.default.emoji || commandEmojis._default
                    };
                }

                // Custom emoji support
                if (module.default.emoji) {
                    commandEmojis[commandName] = module.default.emoji;
                }
            } else {
                console.warn(`âš ï¸ Skipping ${file}: No default export found.`);
                errorCount++;
            }
        } catch (error) {
            console.error(`âŒ Failed to load command '${file}':`, error.message);
            errorCount++;
        }
    }

    console.log(`ðŸš€ Loaded ${loadedCount} commands successfully${errorCount > 0 ? ` (${errorCount} errors)` : ''}`);
    return commands;
};

// Main enhanced message handler
export const messageHandler = async (sock, afkUsers, presenceSettings = {
    TYPING: false,
    AUDIO: false,
    ALWAYS_ONLINE: false
}, options = {}) => {
    if (sock._messageHandlerRegistered) return;
    sock._messageHandlerRegistered = true;

    const commandList = await loadCommands();
    const prefix = process.env.PREFIX || '!';
    
    console.log(`ðŸ¤– Enhanced message handler initialized with prefix: ${prefix}`);

    sock.ev.on('messages.upsert', async ({ messages, type }) => {
        if (type !== 'notify') return;

        for (const msg of messages) {
            try {
                const from = msg.key.remoteJid;
                const userId = msg.key.participant || from;
                
                if (!from || msg.key.fromMe) continue;

                const text = msg.message?.conversation ||
                    msg.message?.extendedTextMessage?.text ||
                    msg.message?.buttonsResponseMessage?.selectedButtonId ||
                    msg.message?.listResponseMessage?.singleSelectReply?.selectedRowId;

                if (!text) continue;

                // Enhanced AFK system with better messages
                if (afkUsers.has(from)) {
                    const afkData = afkUsers.get(from);
                    const timeAway = Math.floor((Date.now() - afkData.timestamp) / 1000);
                    
                    const timeFormat = timeAway > 3600 ? 
                        `${Math.floor(timeAway / 3600)}h ${Math.floor((timeAway % 3600) / 60)}m` :
                        timeAway > 60 ? `${Math.floor(timeAway / 60)}m ${timeAway % 60}s` : `${timeAway}s`;
                    
                    await sock.sendMessage(from, {
                        text: `ðŸ”„ *${afkData.name}* is back!\nâ° Was away for: ${timeFormat}\nðŸ’¬ Reason: ${afkData.reason}`,
                        react: { text: 'ðŸ‘‹', key: msg.key }
                    });
                    afkUsers.delete(from);
                }

                if (!text.startsWith(prefix)) continue;

                const args = text.slice(prefix.length).trim().split(/ +/);
                const commandName = args.shift().toLowerCase();
                const command = commandList[commandName];

                if (!command) {
                    // Smart command suggestions
                    const suggestions = Object.keys(commandList)
                        .filter(cmd => cmd.includes(commandName) || commandName.includes(cmd))
                        .slice(0, 3);
                    
                    let response = `â“ Unknown command: *${commandName}*`;
                    if (suggestions.length > 0) {
                        response += `\n\nðŸ’¡ Did you mean:\n${suggestions.map(s => `â€¢ ${prefix}${s}`).join('\n')}`;
                    }
                    response += `\n\nðŸ“š Use *${prefix}help* for all commands`;
                    
                    await sock.sendMessage(from, { text: response });
                    await sock.sendMessage(from, {
                        react: { text: 'âš ï¸', key: msg.key }
                    });
                    continue;
                }

                // Check cooldown
                if (!checkCooldown(userId, commandName)) {
                    await sock.sendMessage(from, {
                        text: 'â³ Please wait a moment before using this command again.',
                        react: { text: 'ðŸ•’', key: msg.key }
                    });
                    continue;
                }

                // Track command usage
                trackCommandUsage(commandName, userId);

                // Advanced presence handling
                const typingDuration = await handleAdvancedPresence(sock, msg, presenceSettings, commandName);

                // Show loading for complex commands
                let loadingMsg = null;
                const complexCommands = ['weather', 'search', 'translate', 'download'];
                if (complexCommands.includes(commandName)) {
                    loadingMsg = await sendLoadingMessage(sock, from, msg.key);
                }

                // Execute command with enhanced context
                const commandContext = {
                    sock,
                    msg,
                    from,
                    args,
                    userId,
                    userActivity: userActivity.get(userId),
                    greeting: smartResponder.getPersonalizedGreeting(userId),
                    isFirstTime: !userActivity.has(userId)
                };

                // Add beforeResponse callback from options
                if (options.beforeResponse) {
                    const shouldContinue = await options.beforeResponse({
                        commandName,
                        userId,
                        from,
                        msg,
                        args
                    });
                    if (shouldContinue === false) continue;
                }

                try {
                    await command(commandContext.sock, commandContext.msg, commandContext.from, commandContext.args, commandContext);
                    
                    // Smart success reaction
                    const reactionEmoji = getSmartReaction(commandName, true, userId);
                    await sock.sendMessage(from, {
                        react: { text: reactionEmoji, key: msg.key }
                    });

                    // Remember successful interaction
                    smartResponder.rememberContext(userId, commandName, 'success');

                } catch (commandError) {
                    console.error(`ðŸ’¥ Command '${commandName}' failed:`, commandError);
                    
                    const errorReaction = getSmartReaction(commandName, false, userId);
                    await sock.sendMessage(from, {
                        text: `ðŸ’¥ Oops! Something went wrong with *${commandName}*\nðŸ”§ Please try again later.`,
                        react: { text: errorReaction, key: msg.key }
                    });
                }

                // Clean up loading message
                if (loadingMsg) {
                    setTimeout(async () => {
                        try {
                            await sock.sendMessage(from, {
                                delete: loadingMsg.key
                            });
                        } catch (e) {
                            // Ignore cleanup errors
                        }
                    }, 1000);
                }

            } catch (err) {
                console.error('âš ï¸ Message handler error:', err);
                
                try {
                    const from = msg?.key?.remoteJid;
                    if (from) {
                        await sock.sendMessage(from, {
                            react: { text: 'ðŸ’¥', key: msg.key }
                        });
                    }
                } catch (e) {
                    console.error('Failed to send error reaction:', e);
                }
            }
        }
    });

    // Set up hot-reload for development
    if (process.env.NODE_ENV === 'development') {
        const commandsPath = path.join(__dirname, '../commands');
        if (fs.existsSync(commandsPath)) {
            fs.watch(commandsPath, async (eventType, filename) => {
                if (filename && filename.endsWith('.js')) {
                    console.log(`ðŸ”„ Reloading commands due to ${filename} change...`);
                    await loadCommands(true);
                }
            });
        }
    }
};

// Export enhanced utilities
export const commandMap = commands;
export const getCommandStats = () => Object.fromEntries(commandStats);
export const getUserActivity = (userId) => userActivity.get(userId);
export const getAllUserActivity = () => Object.fromEntries(userActivity);

// Admin utilities
export const adminUtils = {
    getTopCommands: (limit = 10) => {
        return Array.from(commandStats.entries())
            .sort(([,a], [,b]) => b - a)
            .slice(0, limit);
    },
    
    getActiveUsers: (limit = 10) => {
        return Array.from(userActivity.entries())
            .sort(([,a], [,b]) => b.commandCount - a.commandCount)
            .slice(0, limit);
    },
    
    resetStats: () => {
        commandStats.clear();
        userActivity.clear();
        cooldowns.clear();
        console.log('ðŸ“Š All stats have been reset');
    }
};